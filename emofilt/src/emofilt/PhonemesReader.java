/*
 * Created on 26.08.2004
 *
 * @author Felix Burkhardt
 */
package emofilt;

import java.io.*;
import org.apache.log4j.*;
import org.xml.sax.InputSource;

import emofilt.util.Util;

import java.util.*;

/**
 * An PhonemesReader reads an utterance description either from a file or from
 * stdin. The description format is MBROLA PHO, e.g.
 * 
 * <pre>
 *  _ 51 25 114 
 *  b 62 
 *  o&tilde; 127 48 170 
 *  Z 110 53 116 
 *  u 211 
 *  R 150 50 91 
 *  _ 91
 * </pre>
 * 
 * <p>
 * or
 * 
 * <pre>
 *  _ 51 (25,114) 
 *  b 62 
 *  o&tilde; 127 (48,170) 
 *  Z 110 (53,116)
 *  u 211 
 *  R 150 (0,100) (50,91) 
 *  _ 91
 * </pre>
 * 
 * <p>
 * probably extended by emofilt syntax enabling the marking of stressed
 * syllables, e.g.:
 * 
 * <pre>
 *  ; pho file generated by emoFilt (http://emofilt.sourceforge.org)
 *  ; a ';-' denotes a syllable start followed by the stresstype (if any)
 *  ; - 
 *  _ 51 (25,114) 
 *  b 62 
 *  o&tilde; 127 (48,170) 
 *  ; - focus
 *  Z 110 (53,116)
 *  u 211 
 *  R 150 (0,100) (50,91)
 *  ; - 
 *  _ 91
 * </pre>
 * 
 * @author Felix Burkhardt
 */
public class PhonemesReader {
	private String filename;

	private Logger _logger = null;

	private Language _lang;

	private boolean _readFromFile = false;

	public PhonemesReader(String filename, Language lang) {
		this.filename = filename;
		_logger = Logger.getLogger(Emofilt.LOGGER_NAME);
		this._lang = lang;
		_readFromFile = true;
		if (lang == null) {
			_logger.error("lang == null (unknown language?)");
		}
	}

	public PhonemesReader(Language lang) {
		_logger = Logger.getLogger(Emofilt.LOGGER_NAME);
		this._lang = lang;
		if (lang == null) {
			_logger.error("lang == null");
		}
	}

	/**
	 * Read the utterance from file or stdin.
	 * 
	 * @return The utterance that was read in.
	 * @throws Exception
	 */
	public Utterance readUtterance() throws Exception {
		if (_readFromFile) {
			return read(new FileInputStream(filename));
		} else {
			return read(System.in);
		}
	}

	/**
	 * Return an utterance given a string containing the pho file.
	 * 
	 * @param s
	 * @return
	 */
	public Utterance readFromString(String s) {
		try {
			return read(new InputSource(new StringReader(s)).getByteStream());
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	private Utterance read(InputStream is) throws Exception {
		Utterance utt = new Utterance();
		Vector ps = new Vector();
		String pName = "";
		int lastF0 = 0;
		int firstF0 = 0;
		boolean firstF0Val = true;
		boolean hasToSetFirstF0Val = false;
		try {
			BufferedReader br = new BufferedReader(new InputStreamReader(is));
			String line;
			boolean sylStart = false;
			boolean focusStress = false;
			boolean wordStress = false;
			while ((line = br.readLine()) != null) {
				if (line.trim().length() > 0) {
					if (line.trim().startsWith(Constants.phoFileSyllableStart)) {
						utt.setSyllableAnnotated();
						sylStart = true;
						if (line.indexOf(Constants.wordStressSymbol) > -1) {
							wordStress = true;
						}
						if (line.indexOf(Constants.focusStressSymbol) > -1) {
							focusStress = true;
						}
					} else if (!line.trim().startsWith(
							Constants.phoFileCommentStart1)
							&& !line.trim().startsWith(
									Constants.phoFileCommentStart2)) {
						// it should be a phoneme description
						StringTokenizer st = new StringTokenizer(line);
						Phoneme p = new Phoneme();
						if (sylStart) {
							sylStart = false;
							p.setSyllableStart(true);
							if (wordStress) {
								p.setSyllableStartWordStressed();
							} else if (focusStress) {
								p.setSyllableStartFocusstressed();
							}
							wordStress = focusStress = false;
						}
						// classify the phoneme
						String token = st.nextToken();
						Phoneme tmpP = _lang.classify(token);
						if (tmpP != null) {
							// else the phoneme wasn't in the language file
							p.setName(tmpP.getName());
							pName = p.getName();
							p.setManner(tmpP.getManner());
							p.setVoiced(tmpP.isVoiced());
							p.copyVariant(tmpP);
							int dur = (int) Double.parseDouble(st.nextToken());
							if (dur >= Constants.frameSize || p.isSilence()) {
								// only regard phone if duration is at least
								// framesize
								p.setDur(dur);
								if (st.hasMoreTokens()) {
									Vector f0Vals = new Vector();
									while (st.hasMoreTokens()) {
										String timeValS = st.nextToken();
										String f0ValS = null;
										// some pho-files have the form
										// "(timeval,f0val)"
										if (timeValS.startsWith("(")) {
											String exprS = timeValS.substring(
													1, timeValS.length() - 1);
											StringTokenizer stExpr = new StringTokenizer(
													exprS, ", ");
											timeValS = stExpr.nextToken();
											f0ValS = stExpr.nextToken();
										} else {
											f0ValS = st.nextToken();
										}
										// remember the last f0-value in case
										// the next voiced phoneme has no
										// description.
										int f0Val = (int) Double
												.parseDouble(f0ValS);
										if (firstF0Val) {
											firstF0 = f0Val;
											firstF0Val = false;
										}
										lastF0 = f0Val;
										F0Val f0 = new F0Val((int) Double
												.parseDouble(timeValS), f0Val);
										f0Vals.add(f0);
									}
									p.setF0vals(f0Vals);
								}
								ps.add(p);
							}
						} else {
							_logger
									.error("couldn't classify phoneme: "
											+ token
											+ ". Perhaps pho-file and language do not match.");
							throw new PhonemeNotFoundException(
									"couldn't classify phoneme: "
											+ token
											+ ". Perhaps pho-file and language do not match.");
						}
					}
				}
			}
			br.close();
			// now fill in missing f0 values so that all phonemes have at least
			// on f0-value
			int start = 0;
			int stepNum = 0;
			for (int i = 0; i < ps.size(); i++) {
				Phoneme pho = (Phoneme) ps.elementAt(i);
				int end = 0;
				if (!pho.hasF0Description()) {
					int stepIndex = 0;
					// s earch for next non-zero f0
					for (int j = i; j < ps.size(); j++) {
						Phoneme pho2 = (Phoneme) ps.elementAt(j);
						if (pho2.hasF0Description()) {
							end = pho2.getFirstF0Val();
							break;
						}
						stepIndex++;
					}
					if (stepNum == 0) {
						stepNum = stepIndex;
					}
					if (start == 0) {
						start = end;
					}
					stepIndex = stepNum - stepIndex + 1;
					if (end <= 0) {
						end = lastF0;
					}
					int nextStep = Util.calcNextStep(start, end, stepIndex,
							stepNum);
					// System.err.println("start " + start + " end " + end
					// + " stepIndex " + stepIndex + " of " + stepNum
					// + " steps, nextStep " + nextStep);
					Vector<F0Val> newVals = new Vector<F0Val>(1);
					newVals.add(new F0Val(50, nextStep));
					pho.setF0vals(newVals);
				} else {
					start = pho.getLastF0Val();
					stepNum = 0;
				}
			}
			utt.setPhonemes(ps);
		} catch (Exception e) {
			_logger.error("something went wrong, last Phoneme:" + pName);
			e.printStackTrace();
			throw (e);
		}
		return utt;

	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}
}